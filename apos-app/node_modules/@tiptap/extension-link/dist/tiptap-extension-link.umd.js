(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@tiptap/core'), require('prosemirror-state')) :
  typeof define === 'function' && define.amd ? define(['exports', '@tiptap/core', 'prosemirror-state'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['@tiptap/extension-link'] = {}, global.core, global.prosemirrorState));
}(this, (function (exports, core, prosemirrorState) { 'use strict';

  /**
   * A regex that matches any string that contains a link
   */
  const pasteRegex = /https?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z]{2,}\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)/gi;
  /**
   * A regex that matches an url
   */
  const pasteRegexExact = /^https?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z]{2,}\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)$/gi;
  const Link = core.Mark.create({
      name: 'link',
      priority: 1000,
      inclusive: false,
      defaultOptions: {
          openOnClick: true,
          linkOnPaste: true,
          HTMLAttributes: {
              target: '_blank',
              rel: 'noopener noreferrer nofollow',
          },
      },
      addAttributes() {
          return {
              href: {
                  default: null,
              },
              target: {
                  default: this.options.HTMLAttributes.target,
              },
          };
      },
      parseHTML() {
          return [
              { tag: 'a[href]' },
          ];
      },
      renderHTML({ HTMLAttributes }) {
          return ['a', core.mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
      },
      addCommands() {
          return {
              setLink: attributes => ({ commands }) => {
                  return commands.setMark('link', attributes);
              },
              toggleLink: attributes => ({ commands }) => {
                  return commands.toggleMark('link', attributes, { extendEmptyMarkRange: true });
              },
              unsetLink: () => ({ commands }) => {
                  return commands.unsetMark('link', { extendEmptyMarkRange: true });
              },
          };
      },
      addPasteRules() {
          return [
              core.markPasteRule(pasteRegex, this.type, match => ({ href: match[0] })),
          ];
      },
      addProseMirrorPlugins() {
          const plugins = [];
          if (this.options.openOnClick) {
              plugins.push(new prosemirrorState.Plugin({
                  key: new prosemirrorState.PluginKey('handleClickLink'),
                  props: {
                      handleClick: (view, pos, event) => {
                          var _a;
                          const attrs = this.editor.getAttributes('link');
                          const link = (_a = event.target) === null || _a === void 0 ? void 0 : _a.closest('a');
                          if (link && attrs.href) {
                              window.open(attrs.href, attrs.target);
                              return true;
                          }
                          return false;
                      },
                  },
              }));
          }
          if (this.options.linkOnPaste) {
              plugins.push(new prosemirrorState.Plugin({
                  key: new prosemirrorState.PluginKey('handlePasteLink'),
                  props: {
                      handlePaste: (view, event, slice) => {
                          const { state } = view;
                          const { selection } = state;
                          const { empty } = selection;
                          if (empty) {
                              return false;
                          }
                          let textContent = '';
                          slice.content.forEach(node => {
                              textContent += node.textContent;
                          });
                          if (!textContent || !textContent.match(pasteRegexExact)) {
                              return false;
                          }
                          this.editor.commands.setMark(this.type, {
                              href: textContent,
                          });
                          return true;
                      },
                  },
              }));
          }
          return plugins;
      },
  });

  exports.Link = Link;
  exports['default'] = Link;
  exports.pasteRegex = pasteRegex;
  exports.pasteRegexExact = pasteRegexExact;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=tiptap-extension-link.umd.js.map
