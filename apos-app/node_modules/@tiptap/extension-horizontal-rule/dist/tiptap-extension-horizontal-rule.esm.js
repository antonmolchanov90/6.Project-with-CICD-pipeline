import { Node, mergeAttributes, nodeInputRule } from '@tiptap/core';
import { TextSelection } from 'prosemirror-state';

const HorizontalRule = Node.create({
    name: 'horizontalRule',
    defaultOptions: {
        HTMLAttributes: {},
    },
    group: 'block',
    parseHTML() {
        return [
            { tag: 'hr' },
        ];
    },
    renderHTML({ HTMLAttributes }) {
        return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
    },
    addCommands() {
        return {
            setHorizontalRule: () => ({ chain }) => {
                return chain()
                    // remove node before hr if it’s an empty text block
                    .command(({ tr, dispatch }) => {
                    const { selection } = tr;
                    const { empty, $anchor } = selection;
                    const isEmptyTextBlock = $anchor.parent.isTextblock
                        && !$anchor.parent.type.spec.code
                        && !$anchor.parent.textContent;
                    if (!empty || !isEmptyTextBlock || !dispatch) {
                        return true;
                    }
                    const from = $anchor.before();
                    const to = $anchor.start();
                    tr.deleteRange(from, to);
                    tr.setSelection(TextSelection.create(tr.doc, from));
                    return true;
                })
                    .insertContent({ type: this.name })
                    // add node after hr if it’s the end of the document
                    .command(({ tr, dispatch }) => {
                    var _a;
                    if (dispatch) {
                        const { parent, pos } = tr.selection.$from;
                        const posAfter = pos + 1;
                        const nodeAfter = tr.doc.nodeAt(posAfter);
                        if (!nodeAfter) {
                            const node = (_a = parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();
                            if (node) {
                                tr.insert(posAfter, node);
                                tr.setSelection(TextSelection.create(tr.doc, posAfter));
                            }
                        }
                        tr.scrollIntoView();
                    }
                    return true;
                })
                    .run();
            },
        };
    },
    addInputRules() {
        return [
            nodeInputRule(/^(?:---|—-|___\s|\*\*\*\s)$/, this.type),
        ];
    },
});

export { HorizontalRule, HorizontalRule as default };
//# sourceMappingURL=tiptap-extension-horizontal-rule.esm.js.map
